---
title: "15-472 Final Project: Terrain Generation"
assignment: 1
author: "Miles Conn, Sam Schaub"
---
import CaptionedImage from "../../components/CaptionedImage.astro";

import Depth from "../../assets/assgn6/depth.png";
import MarchingCubes from "../../assets/assgn6/marchingcubes.png";
import DiffuseTerrain from "../../assets/assgn6/diffuseTerrain.png";
import TexturedTerain from "../../assets/assgn6/texturedTerrain.png";
import MetalProfileTrace from "../../assets/assgn6/metalProfileTrace.png";

# Real-time Procedural Terrain Generation

## Introduction

For the final project of the course, we decided to implement a real-time procedural terrain generation system. 
The goal of this project was to create a system that could generate realistic and visually appealing terrain in real-time, 
allowing for the creation of dynamic and interactive environments. 
We used a combination of fractal noise algorithms and procedural generation techniques to create a variety of terrain types, including mountains and valleys. 
The system is designed to be flexible and customizable, allowing users to adjust parameters such as terrain height, 
roughness, and scale to create unique and interesting landscapes. We used two different techniques to approximate the implicit surface of the terrain: 
marching cubes and ray marching. 

A quick minor note on reading this report. This page was generated with astro and our images use absolute paths instead of relative. We can't test this as we don't have access to republish course
pages on AFS but I (Miles) have used this method for other courses just fine. There might need to be some slight path modifications.

## New features

Running `/bin/viewer` there will be a slight delay as we AOT compute the marching cubes terrain. Afterwards you'll see the terain along with 
the background filled in by the ray march fragment shader. There are a few viewing options

- `V`: toggles marching cubes 
- `0`: switches to the default textured ray march terrain
- `1`: switches to diffuse lighting for the background 
- `2`: switches to a depth map view
- `3`: switches the entire ray march pass off 

## Marching Cubes

Marching cubes is a way to approximate the implicit surface of a 3D scalar field.
The algorithm divides the space into a grid of cubes and then approximates the surface of the scalar field within each cube.
The surface is approximated by creating triangles that intersect the edges of the cube.
The algorithm then uses a lookup table to determine which edges of the cube are intersected by the surface and generates the corresponding triangles.
The triangles are then rendered to create a mesh that approximates the surface of the scalar field.
We implemented this where each GPU thread represents a single cube of marching cubes.
Then it is run on multiple chunks to get more terrain. This computation is done during the scene setup phase, and the resulting meshes is stored in the vertex buffer.
After removing degenerate vertices, we combine duplicate vertices into an index buffer.
Consequently, the resulting terrain is rendered basically for free.
To calculate the UV coordinates for the fragments, we use triplanar projection mapping to get better results for mapping textures to the terrain.
We also added a texture with displacement map to make the terrain more realistic using the technique.

<CaptionedImage src={MarchingCubes} caption="Marching Cubes" />

### Performance

To test performance we setup an XCode Project and recorded a Metal Trace. The algorithm performs well and is able to handle 1.5 million vertices in 2.5 seconds.
However, because the algorithm runs offline, we do not have to run it again so we get long lasting benefits of the marching cubes.
We did not settup handling generating new terrain when the position of the camera moves away from the current terrain, but it something to consider for the future.
Increasing the size of the chunks causes more stress on the GPU and increasing the number of chunks to create increases more stress on the CPU.
This is because the GPU is handling the creation of the chunk so if the chunk size is bigger it will take longer to handle all of the vertices.
And the CPU is handling combining the vertices from all of the chunks so if there are more chunks, then it has to handle more vertices.

## Ray Marching

Ray marching is another technique for approximating the implicit surface of a 3D scalar field.
The algorithm works by casting rays from the camera into the scene and then marching along the ray to find the intersection point with the surface.
The distance to the surface is calculated at each step, and the ray is marched until it intersects the surface or reaches a maximum distance.
We implemented this technique using a fragment shader to render the terrain. The terrain is generated by sampling a 3D noise function and using the resulting value to calculate the height of the terrain at each point.
We then use the ray marching algorithm to calculate the intersection point of the ray with the terrain and render the terrain.

<CaptionedImage src={DiffuseTerrain} caption="With diffuse lighting we can see the approximated noise function generated in the ray march"/>

<CaptionedImage src={TexturedTerain} caption="Textured terrain generated by the ray march"/>

### Bugs

We ultimately wanted the noise function to perfectly line up with the marching cubes to create seamless surfaces.
We found that there are some bugs in our math that lead this to not working. We think the issue is how we are transforming 
from clip space to world space. We spent a considerable amount of time debugging and couldn't get it to work. This is usually not 
that noticeable as long as the camera doesn't go to any crazy angle.

### Performance

During ray marching we define an implicit scene made up of terrain approximated by a function and a sky. Our code becomes incredibly
slow when we need to color sky pixels as it requires our ray march to run for the full length of the ray. One optimization we implemented 
was to check to see if the ray was above the horizon. In this case we'd forego the ray march and just color that sky. This method would fail 
if we had giant mountains but works fairly well in our testing to prevent the fragment shader from hitting the worst code paths.
This technique is slower than ray marching because it generating the terrain each frame.
However, there is no geometry, so it saves a lot of memory.

## Combined Approach

We wanted to combine both of these approaches such that the foreground of the scene would be the result of the marching cubes algorithm and the background would be the result of the ray marching algorithm. 
In order to do this we needed to construct a depth buffer in order to determine if the terrain from the marching cubes is in front. 

<CaptionedImage src={Depth} caption="Depth Map rendering" />

We then take the depth buffer in as a subpass input and read from it to conditionally check if we should run the ray march code. 
This took a long time to implement and debug and it dawned on us all too late that the depth buffer values were accurate
but needed to be scaled to be visible. In the fragment shader there is a function that arbitrarily scales them to make them more 
readable when viewed directly. 

### Performance 

The ultimate goal would be to measure performance looking at the horizon. We could then measure performance 
as marching cube terrain, that extends to the horizon, takes up fewer fragments thus being less helpful. In this case it would 
make more sense to use the fragment shader to generate far off terrain as it's complexity scales with fragments as opposed
to vertices.

<CaptionedImage src={MetalProfileTrace} caption="Metal Profile Trace"/>

As seen, the first 2.5 seconds, there is no drawinng because the marching cubes algorithm is generating the terrain meshes.

Closeup to the precomputed terrain, we get very fast draw times which makes sense as we only need to do texture lookups.

When we zoom out such that we start to see the ray marched scene our perform drops a hair as our fragment shader is also estimating
the noise function. This still runs at real-time frame rates, so it is very reasonable.

Our worst performance is when we tilt the camera such that the sky is visible in our implicit ray marched scene. This is because the ray needs
to traverse the entire way to see if it intersects with the sky. While we imlemented an optimization to prevent this it does occasionally get past our heuristic check.
This causes our performance to move into the interactive category.


## Conclusion and Further Work

Our project was a good proof of concept for combining multiple implicit surface generation techniques to create an interesting terrain. 
There are many areas of improvement such as optimizing the performance of the the marching cubes and ray marching algorithms. For instance,
in ray marching we could take adaptive steps to speedup the collision.
We could also add lighting, and since we already have a depth map, we could add ambient occlusion.  We tried to implement this but currently we're accessing
the depth map as a subpass input instead of as an image which makes indexing into it to calculate screen space occlusion impossible.
Furthermore, we could add more complex terrain generation to create rivers and lakes. If we don't want to use multiple textures 
this would then mean we need more complicated ray march draw code.


Overall, we are very happy with the results of our project and we believe that it has a lot of potential for further development.

## References

1. Textures for the terrain: https://polyhaven.com/a/coast_sand_rocks_02
1. Marching cubes: https://paulbourke.net/geometry/polygonise/
1. Triplanar mappign: https://www.martinpalko.com/triplanar-mapping/
1. Fractal Brownian Motion: https://thebookofshaders.com/13/
1. Subpass Inputs: https://www.saschawillems.de/blog/2018/07/19/vulkan-input-attachments-and-sub-passes/
1. Ray Marching Overview: https://iquilezles.org/articles/terrainmarching/